import numpy as np


def simulated_annealing(loss_fn, start_points, field_size, steps=300):
    starts = np.array(start_points, dtype=float).copy()
    paths = []
    rng = np.random.default_rng(114514)

    for start in starts:
        x, y = start
        current_gpa = loss_fn(x, y)
        best_x, best_y, best_gpa = x, y, current_gpa
        temp_start = 2.0
        path = [(x, y, current_gpa, best_x, best_y, best_gpa, temp_start)]
        temp_decay = 0.8
        step_size = 0.2
        temp = temp_start
        for _ in range(steps):
            # --- Homework algo2: Implement Simulated Annealing ------
            # Steps:
            # 1. Choose a neighbor: dx, dy ? { -step_size, 0, +step_size }
            # 2. Compute the new candidate (nx, ny) and evaluate loss_fn (next_gpa)
            # 3. Compute delta = next_gpa - current_gpa
            # 4. Accept the move if:
            #       �V delta > 0   (improves solution), OR
            #       �V with probability exp(delta / temp)   (explores worse solutions)
            # 5. Update best state if current_gpa is better than best_gpa
            # 6. Decay the temperature (temp *= decay_rate)
            # ---------------------------------------------------------
            # --- IMPLEMENTATION START ---
            """
            rng.choice() 的功能是從給定的選項中隨機選擇一個元素。
            param 1: 要選擇的選項列表(List, Tuple, Array)
            return: 隨機選擇的元素
            """
            dx = rng.choice([-step_size, 0, step_size])
            dy = rng.choice([-step_size, 0, step_size])
            nx = x + dx
            ny = y + dy
            """
            np.clip() 的功能是將輸入的數值限制在指定的範圍內。
            param 1: 要限制的數值
            param 2: 最小值
            param 3: 最大值
            return: 限制後的數值
            """
            nx = np.clip(nx, field_size[0], field_size[1])
            ny = np.clip(ny, field_size[0], field_size[1])
            next_gpa = loss_fn(nx, ny)
            delta = next_gpa - current_gpa
            accept = False
            if delta > 0:
                accept = True
            else:
                prob = np.exp(delta / temp)
                if rng.uniform(0, 1) < prob:
                    accept = True
            if accept:
                x, y = nx, ny
                current_gpa = next_gpa
            temp *= temp_decay
            # --- IMPLEMENTATION END ---

            # ------------------------------------------------
            # "path" means the whole trajectory of one ship from start to end.
            # Each entry in path should include:
            #   - current ship (x, y, gpa, temp)
            #   - best (x, y, gpa) found so far by this ship
            #
            # You can check example_1.txt (generated by main.py) to verify if your code
            #   produces a similar format and result.
            # You can also refer to algo_example.py for a better understanding.
            # Note: best_gpa should only increase over time.
            # ------------------------------------------------
            if current_gpa > best_gpa:
                best_x, best_y, best_gpa = x, y, current_gpa
            path.append((x, y, current_gpa, best_x, best_y, best_gpa, temp))
        paths.append(path)
    return paths
