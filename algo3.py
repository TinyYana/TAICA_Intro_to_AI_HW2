import numpy as np


def ultimate_algorithm(loss_fn, start_points, field_size, steps=300):
    # starts = np.array(start_points, dtype=float).copy()
    paths = []
    # 跨度高一點比較容易找到最優解
    step_size = 0.3
    n_ships = len(start_points)
    x_min, x_max = field_size
    region_height = (x_max - x_min) / n_ships
    rng = np.random.default_rng(0)

    # Enumerate 同時拿到索引和值
    for i, (sx, sy) in enumerate(start_points):
        y_low = x_min + i * region_height
        y_high = y_low + region_height
        x = float(np.clip(sx, x_min, x_max))
        y = float(np.clip(sy, y_low, y_high))
        current_gpa = loss_fn(x, y)
        best_x, best_y, best_gpa = x, y, current_gpa
        path = [(x, y, current_gpa, best_x, best_y, best_gpa)]

        for _ in range(steps):
            neighbors = []
            for dx in [-step_size, 0, step_size]:
                for dy in [-step_size, 0, step_size]:
                    if dx == 0 and dy == 0:
                        continue
                    nx, ny = x + dx, y + dy
                    # 確保鄰居在範圍區間內
                    if not (x_min <= nx <= x_max and y_low <= ny <= y_high):
                        continue
                    neighbors.append((nx, ny))
            if not neighbors:
                break
            # 找出鄰居中 GPA 最好的
            nx_best, ny_best, gpa_best = max(
                [(nx, ny, loss_fn(nx, ny)) for nx, ny in neighbors],
                key=lambda item: item[2],
            )

            if gpa_best > current_gpa:
                x, y, current_gpa = nx_best, ny_best, gpa_best
            else:
                break

            if current_gpa > best_gpa:
                best_x, best_y, best_gpa = x, y, current_gpa
            path.append((x, y, current_gpa, best_x, best_y, best_gpa))
        paths.append(path)
    return paths


"""
            # --- Homework: Implement the Ultimate Algorithm ---
            # You may either:
            #
            # ? Choose an existing method (e.g., Local Beam Search, Genetic Algorithm, etc.)
            #     Example: Local Beam Search
            #     Steps if you choose Local Beam Search:
            #       1. For each current state, generate all 8 neighbors
            #          (using step_size in x and/or y)
            #       2. Collect all neighbors from all k beams
            #       3. Evaluate each neighbor with loss_fn (GPA)
            #       4. Select the top-k neighbors (highest GPA values)
            #       5. These become the new states for the next iteration
            #       6. Append the chosen states to their corresponding paths
            #
            # ? Modify Hill Climbing or Simulated Annealing into an improved version
            #
            # ? Design your own original algorithm
            #
            # ------------------------------------------------------

            # --- IMPLEMENTATION START ---

            # --- IMPLEMENTATION END ---

            # ------------------------------------------------
            # "path" means the whole trajectory of one ship from start to end.
            # Each entry in path should include:
            #   - current ship (x, y, gpa)
            #   - best (x, y, gpa) found so far by this ship
            #
            # "paths" means the collection of all ships' trajectories.
            # For this homework, it should contain 10 paths (one per ship).
            # You can check example_10.txt (generated by main.py) to verify if your code
            #   produces a similar format and result.
            # You can also refer to algo_example.py for a better understanding.
            # Note: best_gpa should only increase over time.
            # ------------------------------------------------
"""
